<작업 예약 at & cron>
- 주기적으로 반복해야하는 작업에 사용하는 데몬
  (주로 서버부하가 적은 새벽에 예약한다.)

# rpm -qa | grep at	: at 사용하기 위한 패키지 설치 유무 확인
# rpm -qa | grep mail	: mail 사용하기 위한 패키지 설치 유무 확인
# rpm -qa | grep cron	: cron	사용하기 위한 패키지 설치 유무 확인

# yum -y install at	: at 설치
# yum -y install mail	: mail 설치

===========================================================================
# at [옵션] [시간]
: 정해진 시간에 한번 실행
  at 예약 작업은 /var/spool/at 디렉토리에 큐 파일이 임시 저장된 후
  작업이 완료되면 자동으로 삭제되며, 명령의 실행 결과 중 mail을 보내기로 
  되어있는 작업은 /var/spool/mail 디렉토리에 사용자 명으로 결과가 저장된다.

옵션	의미
-l	현재 실행 대기중인 목록을 출력 (= #atq)
-r	현재 실행 대기중인 명령에서 해당 작업 번호 삭제 (= #atrm)


시간 형식
yyyy-mm-dd	HH:MM	HHMM	today		tomorrow	hours
days		weeks	now	midnight	teatime

ex) 
#at 6pm + 4days 	: 지금부터 4일후 오후6시에 작업을 수행
#at 10am jul 18		: 7/18 오전 10시에 작업을 수행
#at now + 1min		: 지금부터 1분 뒤에 작업 수행
#at 3am tomorrow	: 내일 오전 3시에 작업을 수행
#at 10:00am today	: 오늘 오전 10:00에 작업을 수행

ex)
# service atd start	: at명령어 전에 꼭 해줘야됨!
# at now + 1min
at> mkdir -p /practice/01-19
at> echo "at test!!" > /practice/01-19/at-test
at> <EOT>		: Ctrl+D 누르면 저장됨 <EOT>는 End of Tranmission
---------------------------------------------------------------------------
<at의 사용권한 설정>
- /etc/at.allow 파일이 있으면, at.allow에 명시된 사용자만 사용이 가능.
- /etc/at.allow 파일이 없으면, at.deny에 명시된 사용자를 제외하고 사용 가능
- /etc/at.allow 파일이 없고,at.deny가 빈파일이면 모든 사용자가 사용 가능
- 두 파일이 모두 없으면 root만 사용 가능
- 두 파일모두에 이름이 있다면, /etc/at.allow가 우선 적용되어 사용가능
- at.deny 파일을 빈파일로 두면 모든 사용자가 at 명령어 사용가능 (기본값)

===========================================================================
# crontab
기능: crontab 파일 관리 반복 가능
형식: crontab -u [user id] [옵션]

옵션	의미
-e	사용자의 crontab 편집
-l	crontab 파일의 목록 출력
-r	crontab 파일을 삭제
-u	crontab 할 사용자 명 입력할 것

ex)
# crontab -l 		  : crontab list 확인
# crontab -u cron_user -e : cron_user의 crontab 수정

crontab 파일의 형식(/etc/crontab)
- crontab 파일은 사용자 별로 생성되며, 해당 파일에는 반복할 작업의 내용이 있다.
- 여러개의 작업도 저장할 수 있으며, 한 행에 하나의 작업만 설정해야한다.]

<작업 입력 필드>

 분	시	일	월	요일 	작업내용
0~59	0~23	1~31	1~12	0~6	반복할 작업의 내용
				일=0
- 각 항목은 공백 문자로 구분시키면 된다
- 항목의 값이 '*'이면 해당 항목의 모든 값을 의미함
- '-'두 숫자 사이에 포함된 범위 (1-5 = 1,2,3,4,5)
- ','로 구분하여 나열된 숫자 중 일치하는 경우를 뜻한다
- '/'로 시간 간격을 정할 수 있다.(분=*/2 : 2분마다

ex)
# 30 23 1 * * cp/home/test/backup/test
: 모든 요일 매월1일 23시30분에 해당작업을 하겠다.

# */2 10 * * * 
: 매요일 매월매일 10시 중 2분마다 작업

# 1-10 12 * * *
: 매요일 매월매일 12시 1분부터 10분까지 작업

---------------------------------------------------------------------------
# crontab -e
: crontab 파일 생성과 편집
  /var/spool/cron 디렉토리에 사용자 이름을 예약 작업 파일 생성됨
  명령어 치고나서 필드를 입력하라
->
1,2,3 * * * * touch /practice/cron_test/cron1_$(date +\%y-\%m-\%d-\%dH-\%M-\%S)
1-3 * * * * touch /practice/cron_test/cron2_$(date + \%y-\%m-\%d-\%H-\%M-\%S)

# crontab -l
: 파일 내용 확인하기, 현재 사용자의 crontab 내용 출력


# watch -d -n 1 "ls /practice/cron_test/"
: 시간에 따른 ""안의 명령의 진행상황을 보는것
---------------------------------------------------------------------------
<crontab 의 사용권한 설정>
-/etc/cron.allow /etc/cron.deny 파일로 사용자의 접근을 허용,차단할 수 있다
-at의 사용권한 설정과 동일하다

===========================================================================
<리눅스 마스터 1,2급 시험 문제 중>
ALSA - 사운드 카드 관련 데몬
CUPS - 프린터 관련 데몬
SANE - 스캐너, 비디오 캠 관련 데몬
===========================================================================
<파일 시스템 관리>

파일 시스템이란? 
- 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 체제
- 파일 저장 및 검색을 용이하도록 유지,관리하며 빠르게 읽고 사용할 수 있도록
  만들어 놓은 규칙

리눅스 지원 파일 시스템의 종류
- EXT3, EXT4, SWAP, XFS, NFS, ISO9660

EXT4 FileSystem
- 1EB의 파일 시스템 사이즈와 최대 16TB의 파일 사이즈 지원
  (기가 - 펙타 - 엑사바이트)
- 서브 디렉토리 64000개 지원하고, 파일은 약 40억개 생성가능


Disk 종류 (오래된 순)
1.IDE	(Integrated Drive Electronics)
2.SATA	(Serial Advanced Technology Attachment)
3.SCSI	(Small Computer System Interface)
4.SAS	(Serial Attached SCSI)

===========================================================================
SWAP 파티션
- 하드 디스크 영역을 가상메모리처럼 사용하기 위해 만든 파티션
- 메모리가 부족할 경우, 하드 디스크를 사용하여 예비 공간 역할을 함

RAM크기별 SWAP의 크기
RAM		SWAP
2GB이하		RAM의2배
2~8GB		RAM과동일
8~64GB		4GB 이상
===========================================================================
파티션 (Partition)
하나의 물리적인 하드 디스크를 여러개의 논리적인 디스크로 나누는 것

# df -h
:파티션이 나뉘어진 것과 그 용량을 볼 수 있다.

리눅스 파티션
- 파티션은 주파티션(Primary)과 확장파티션(Extended),논리파티션(Logical)
- Disk1개당 주파티션은 4개까지 생성가능
- 그 이상 파티션이 필요할 때는 확장 파티션을 생성
- 확장 파티션은 다시 논리 파티션으로 나누어지고 최대 12개까지 생성 가능
- 3개 주파티션,1개의 확장파티션,12개의 논리파티션으로 나눌수 있다
- 확장파티션은 논리파티션을 위한 파티션이기 때문에 저장공간을 사용불가
- 실제 데이터가 저장되는 파티션은 주파이션과 논리파티션이다

파티션 명칭
ex) /dev/sda 1번 디스크		 /dev/sdb 2번 디스크
    /dev/sdc 3번 디스크 	 /dev/sdd 4번 디스크
1개의 disk에 3개의 파티션 ->	/dev/sda1
				/dev/sda2
				/dev/sda3
2개의 disk에 2개의 파티션 -> /dev/sda1
			     /dev/sda2
			     /dev/sdb1
			     /dev/sdb2

1개의 disk에 1개의 주파티션,1개의 확장파티션,1개의 논리파티션
/dev/sda1 (주파티션-1부터4까지)
/dev/sda5 (확장파티션-무조건5)
/dev/sda6 (논리파티션-6부터17까지)

---------------------------------------------------------------------------
# fdisk [옵션] [장치명]
: 파티션 생성 및 수정
옵션	의미
-l	디스크 정보 출력
-p	해당 티스크 파티션 목록 출력
-w	저장 후 종료
-t	파티션 타입 변경
-n	새로운 파티션 추가
-d	파티션 제거


새로운 disk 추가 -> 파티션 생성(주파티션1개)
#fdisk /dev/sdb
n	파티션생성
p	주파티션생성
1	주파티션 번호
	실린더크기설정(default값으로 설정했음)
p	파티션 목록 출력
w	저장하고 나감
---------------------------------------------------------------------------


=====================================================================
=====================================================================
RAID 1
-미러링(Mirroring) RAID
-총 Disk 50% 사용이 가능
-데이터를 여러번 기록하면서 걸리는 시간때문에 성능이 감소
-한 개의 디스크가 고장나면 볼륨의 다음 디스크에서 데이터를 사용
-  

1.fdisk 파티션 생성 후, 타입 변경 fd(Linux Raid Autodetect)
 (1)fdisk /dev/sdf 


===========================================================================

구분		RAID 0		RAID 1
성능(속도)	뛰어남		변화없음
안정성(결함허용)보장못함	보장함
공간 효율성	좋음		나쁨
--------------------------------------------------------------------------
RAID 5
- RAID 1처럼 데이터의 안정성도 보장되면서, RAID 0처럼 공간효율성도 좋다
- 최소 3개 이상의 Disk가 필요하고 보통 5개 이상으로 구성한다
- Disk 오류 발생 시 패리티를 이용하여 데이터를 복구한다
- 각 Disk 용량이 1TB일때, 4개의 Disk Raid5를 구성 시 3TB만 사용이 가능하다
  (하드 디스크 개수 -1 만큼의 공간(패리티))

패리티(Parity)
- 디스크 장애 시 데이터를 재구축하는데 사용할 수 있는 계산된 값
- RAID 5에서 Disk 장애발생 시 패리티를 복구하기전에 또 다른 디스크가 
  고장이 나면 레이드 볼륨의 데이터가 손실된다.

ex)
4개의 Disk로 구성된 RAID 5 저장방식
데이터 정보	: 000 111 010 101
데이터 저장방향 : -> -> -> ->
□		: 패리티
A	B	C	D 디스크에 데이터정보를 저장할때 예시
0	0	0	□
1	1	□	1
0	□	1	0
□	1	0	1

디스크 개수가 짝수일 경우 : 짝수 패리티 사용 (1과0의 값이 무조건 짝수)
디스크 개수가 홀수일 경우 : 홀수 패리티 사용 (1과0의 값이 무조건 홀수)


A	B	C	D 
0	0	0	□=0
1	1	□=1	1
0	□=1	1	0
□=0	1	0	1

이때 C 디스크의 값이 없어지면 각 라인의 1,0의 값이 짝수여야하므로
C 디스크 데이터를 예측할 수 있다
---------------------------------------------------------------------------

오늘 한내용 복습하기







