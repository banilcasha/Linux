프로세스관리

init - 부팅 시 가장 먼저 실행되는 시스템 초기화 프로세스

프로세스
- 커널의 관리하에 현재 시스템 동작 중인 프로그램이다.
- init을 제외한 모든 프로세스는 부모-자식 관계를 가지고 있다.

프로세스의 종류
- 데몬 (daemon)프로세스
	커널에 의해서 실행되고, 특정 서비스를 제공한다.
	ex) 웹 서버를 동작하기 위해서는 httpd라는 프로세스가 동작하고 있으ㅇ
	    하며 httpd를 웹 서버 데몬이라고한다.
- 부모 프로세스
	부모 프로세스는 다른 프로세스를 만들며, init을 제외한 모든 프로세스는
	부모 프로세스를 가지고 있다.
	
- 자식 프로세스
	부모 프로세스의 의해 만들어지는 프로세스이다.
	자식 프로세스는 종료시 부모 프로세스에게 결과를 전달하고 종료된다.
	
- 고아 프로세스
	자식 프로세스보다 먼저 부모프로세스가 종료되었을때 해당 자식프로세스
	는 고아 프로세스가되어 init관리하에 들어가게된다.

- 좀비 프로세스
	자식 프로세스의 종료신호를 보무프로세스 처리 하지 못할 경우
	자식프로스는 좀비 프로세스 된다.
	
-------------------------------------------------------------------------
ps (Process Status)- 시스템에 동작인 프로세스 확인

#ps 현재 터미널에 실행되고 있는 프로세스에 간단한 정보만 출력  

-e 모든 프로세스에 대한 리스트 출력
-f full format으로 출력

-a 다른 사용자들의 프로세스도 출력
-u 사용자 이름, 시간 등 상세한 정보를 출력
-x 지금 사용되고 있는 모든 프로세스를 출력

UID - 프로세스를 실행 시킨 프로세스 소유자를 의미
PID - 실행된 프로세스 부여된 숫자를 의미
PPID - 부모 프로세스의 PID
C - 프로세스 스케줄링을 위한 CPU 사용량을 나타냄 (현재는 사용하지않음)
STIME - 프로세스가 시작 시작된 시간
TTY - (TELETYPE) 프로세스가 연결된 제어 터미널 표시
	   '?'는 터미널에 연결되어 있지 않음을 타나냄
TIME - 프로세스에 의해 사용된 CPU 사용 시간
CMD - 실행된 프로세스 명(실행된 명령어)
-------------------------------------------------------------------------
세션2 : /bin/bash/ -> vi /etc/service
세션1 : pid 보면서 vi의 부모프레스 bash 종료
        kill -9 [vi의 PPID]
		
		ps -ef
		vi /etc/service 프로세스의 PID 번호 확인
		
-------------------------------------------------------------------------
kill - 프로세스 종료
kill -[시그널] [PID]

kill -SIGKILL 1385	//같은 명령어
kill -9 1385

시그널 종류 확인
kill -l 

자주 사용하는 시그널
2) SIGINT - 프로세스 종료
9) SIGKILL - 프로세스 강제종료
15) SIGTERM - 프로세스 종료
19) SIGSTOP - 프로세스 정지

--------------------------------------------------------------------------
프로세스 동작 형태

포어그라운드 프로세스
	- 프롬프트에서 입력하는 대부분의 명령어는 포어 그라운드로 동작
	- 명령어의 실행과정이나 결과를 화면에 출력
	- 포어 그라운드로 실행되는 프로세스는 종료되길 기다렸다가
	  종료 시 다시 프롬프트 보여주어 명령대기 상태로 변환
	  
ex) 세션 1 : cp -r /usr /practice			//포어그라운드 프로세스 실행
    세션 2 : ps -ef | grep cp				//프로세스 확인 (PID)
	세션 2 : kill -9 [PID]
	세션 1 : 종료확인
	  
백 그라운드 프로세스
	- 프로세스의 종료 여부에 관계 없이 즉시 명령 대기 상태가 되어
	  다른 명령어를 실행 시킬 수 있음
	- 백 그라운드로 실행 시키기 위해서는 ampersand (&)를 붙여 사용
    - 장시간 실행되어야 하는 경우에 주로 사용

	ex) [명령어] &
	작업 번호와 PID를 출력하면 백그라운드로 동작
	
	세션 1 : cp -r /usr /practice/day1 &
	세션 2 : ps -ef | grep cp				
    세션 2 : kill -9 [PID]
    세션 1 : 종료확인
 	
jobs - 백그라운드에서 동작하고 있는 프로세스를 확인
	[+] 기호는 현재  작업 중
	[-] 대기 중
fg	백그라운드 작업을 포어 그라운드로 변경 시 사용
bg  포어브라운드 작업을 백그라운드로 변경 시 사용

sleep 9999								//포어 그라운드 실행 
Ctrl + Z (19) SIGSTOP - 프로세스 정지)	//정지 후
bg %[작업번호]							//백 그라운드로 실행
								
sleep 9999 &					//백 그라운드 실행
jobs 							//백 그라운드 작업번호 확인
fg %[작업번호]					//포어 그라운드로 실행

  백그다운드 작업을 정지 시켜보기
#sleep 9999 &					//백 그라운드 작업 실행
jobs							//Running 상태 확인
PID 확인
#ps -ef | grep sleep
PID 확인

#kill -[정지 시그널] [PID]		
18) SIGCONT						//정지한 프로세스 재시작
19) SIGSTOP						//프로세스 정지

jobs 명령어로 정지 확인			//Stop 상태 확인


좀비 프로세스 제거 방법
ps -aux (STAT 필드 Z (Zombie)
- SIGCHLD 신호를 전송
- 부모프로세스를 종료
- 재부팅
------------------------------------------------------------------------

	
	
	
	
	
	
	
	
	
	
	
	